include "pipelines/common.glsl"

texture_slot {
	name = "Heightmap",
	uniform = "u_hm",
	default_texture = "textures/common/white.tga"
}

texture_slot {
	name = "Albedo",
	uniform = "u_albedo",
	default_texture = "textures/common/white.tga"
}

texture_slot {
	name = "Splatmap",
	uniform = "u_splatmap",
	default_texture = "textures/common/white.tga"
}

vertex_shader [[
	out int v_vid;
	
	void main()
	{
		v_vid = gl_VertexID;
	}
]]


geometry_shader [[
	layout (points) in;
	layout (triangle_strip, max_vertices = 4) out;
	in int v_vid[];
	
	out vec2 v_uv_sub;
	out vec2 v_uv;
	uniform sampler2D u_hm;
	uniform vec3 u_position;
	uniform int u_lod;
	uniform vec3 u_rel_camera_pos;
	uniform ivec4 u_from_to;
	uniform vec4 u_uv_from_to;

	
	const float hscale = 128;

	
	void getVertex(ivec2 ij, out vec3 pos, out vec2 uv_sub)
	{
		pos = vec3(ij.x, 0.0, ij.y) * (1 << u_lod);
		vec3 npos = vec3(ij.x & ~1, 0.0, ij.y & ~1) * (1 << u_lod);

		vec2 size = vec2(u_from_to.zw - u_from_to.xy);
		uv_sub = (ij - u_from_to.xy) / size;
		uv_sub = mix(u_uv_from_to.xy, u_uv_from_to.zw, uv_sub);
		
		vec2 rel = saturate(abs(uv_sub - vec2(0.5)) * 10 - 4);
		
		pos.x = mix(pos.x, npos.x, rel.y);
		pos.z = mix(pos.z, npos.z, rel.x);
		
		uv_sub = (pos.xz / float(1 << u_lod) - u_from_to.xy) / size;
		uv_sub = mix(u_uv_from_to.xy, u_uv_from_to.zw, uv_sub);
	}
	
	void main()
	{
		vec2 v_step;
		ivec2 size = ivec2(u_from_to.zw - u_from_to.xy);
		v_step = 1.0 / size;

		vec2 v_rel;
		v_rel.x = (v_vid[0] % size.x) / float(size.x);
		v_rel.y = (v_vid[0] / size.x) / float(size.y);
		
		ivec2 ij = ivec2(
			u_from_to.x + v_vid[0] % size.x,
			u_from_to.y + v_vid[0] / size.x
		);
		
		vec2 v_lod_uv;
		v_lod_uv.x = (v_vid[0] % size.x) * v_step.x;
		v_lod_uv.y = (v_vid[0] / size.x) * v_step.y;
		
		v_lod_uv = u_uv_from_to.xy + (u_uv_from_to.zw -  u_uv_from_to.xy) * v_lod_uv;
		
		v_step *= u_uv_from_to.zw - u_uv_from_to.xy;
		
		vec2 rel = saturate(abs(v_lod_uv - vec2(0.5)) * 10 - 4);
		
		float s = pow(2, u_lod);
			
		vec3 v;
		getVertex(ij, v, v_uv_sub);
		v_uv = v.xz / 2048;
		float h = texture(u_hm, v.xz / 2048).x * hscale;
		gl_Position = u_camera_view_projection * vec4(u_position + v + vec3(0, h, 0), 1);
		EmitVertex();

		getVertex(ij + ivec2(1, 0), v, v_uv_sub);
		v_uv = v.xz / 2048;
		h = texture(u_hm, v.xz / 2048).x * hscale;
		gl_Position = u_camera_view_projection * vec4(u_position + v + vec3(0, h, 0), 1);
		EmitVertex();

		getVertex(ij + ivec2(0, 1), v, v_uv_sub);
		v_uv = v.xz / 2048;
		h = texture(u_hm, v.xz / 2048).x * hscale;
		gl_Position = u_camera_view_projection * vec4(u_position + v + vec3(0, h, 0), 1);
		EmitVertex();

		getVertex(ij + ivec2(1, 1), v, v_uv_sub);
		v_uv = v.xz / 2048;
		h = texture(u_hm, v.xz / 2048).x * hscale;
		gl_Position = u_camera_view_projection * vec4(u_position + v + vec3(0, h, 0), 1);
		EmitVertex();
		EndPrimitive();
	}
]]


fragment_shader [[

	#ifdef DEFERRED
		layout(location = 0) out vec4 o_gbuffer0;
		layout(location = 1) out vec4 o_gbuffer1;
		layout(location = 2) out vec4 o_gbuffer2;
	#else
		layout(location = 0) out vec4 o_color;
	#endif

	in vec2 v_uv_sub;
	in vec2 v_uv;
	layout(binding = 0) uniform sampler2D u_hm;
	layout(binding = 1) uniform sampler2DArray u_slices;
	uniform int u_lod;

	const float hscale = 128;

	vec3 getNormal(vec2 uv)
	{
		vec3 off = vec3(-1.0/2048.0, 0, 1.0/2048.0);
		float s01 = texture2D(u_hm, uv + off.xy).x;
		float s21 = texture2D(u_hm, uv + off.zy).x;
		float s10 = texture2D(u_hm, uv + off.yx).x;
		float s12 = texture2D(u_hm, uv + off.yz).x;
		vec3 va = normalize(vec3(1.0, (s21-s01) * hscale, 0.0));
		vec3 vb = normalize(vec3(0.0, (s12-s10) * hscale, 1.0));
		return normalize(cross(vb,va));
	}
	
	void getData()
	{
		data.normal = getNormal(v_uv);
		data.albedo = pow(texture(u_slices, vec3(v_uv_sub, u_lod)), vec4(2.2));
		#ifdef ALPHA_CUTOUT
			if(data.albedo.a < 0.5) discard;
		#endif
		data.wpos = vec3(0);
		data.roughness = 0.9;
		data.metallic  = 0;
		data.emission = 0;
	}
	
	#ifdef DEPTH
		void main()
		{
		}
	#elif defined DEFERRED
		void main()
		{
			getData();
			o_gbuffer0 = vec4(data.albedo.rgb, data.roughness);
			o_gbuffer1 = vec4(data.normal, data.metallic);
			o_gbuffer2 = vec4(data.emission, 0, 0, 1);
		}

	#else 
		void main()
		{
			getData();
			
			o_color.rgb = vec3(1, 0, 1);
				
			o_color.w = 1;
		}
	#endif
]]